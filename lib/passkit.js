// Generated by CoffeeScript 1.6.2
(function() {
  var API, HOST, PORT, PassKit, PassKitError, crypto, fs, generateHex, https, md5, mime, parseDigest, parsePassURL, querystring, renderDigest, sanitize, supportsPassbook;

  crypto = require("crypto");

  fs = require("fs");

  querystring = require("querystring");

  https = require("https");

  mime = require("mime");

  HOST = "api.passkit.com";

  API = "/v1";

  PORT = 443;

  generateHex = function(length) {
    if (length == null) {
      length = 6;
    }
    return crypto.randomBytes(length).toString("hex");
  };

  md5 = function(value) {
    return crypto.createHash("md5").update(value).digest("hex");
  };

  PassKitError = function(message) {
    if (message == null) {
      message = '';
    }
    Error.call(this);
    Error.captureStackTrace(this, arguments.callee);
    this.message = message;
    return this.name = "PassKitError";
  };

  PassKitError.prototype.__proto__ = Error.prototype;

  parseDigest = function(header) {
    var headerArray, key, pair, parameter, parameters, value, _i, _len;

    parameters = [];
    headerArray = header.substring(6).split(/,\s*/);
    if (headerArray.length > 1) {
      for (_i = 0, _len = headerArray.length; _i < _len; _i++) {
        parameter = headerArray[_i];
        pair = parameter.split("=");
        key = pair[0].replace(/\s*/g, "");
        value = pair[1].replace(/"/g, "");
        parameters[key] = value;
      }
    }
    return parameters;
  };

  renderDigest = function(parameters) {
    var header, key, _i, _len, _ref;

    header = "Digest ";
    _ref = Object.keys(parameters);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      header += "" + key + "=\"" + parameters[key] + "\", ";
    }
    if (header === "Digest ") {
      return null;
    }
    return header.substring(0, header.length - 2);
  };

  sanitize = function(value) {
    return value.replace(/[^\w\.\/]/gi, "");
  };

  parsePassURL = function(url) {
    if (url[url.length - 1] === '/') {
      url = url.substring(0, url.length - 1);
    }
    if (!/http(s)*:\/\/(.+)/i.test(url)) {
      throw new PassKitError("Invalid string!");
    }
    return /http(s)*:\/\/(.+)\/(.*)/i.exec(url)[3];
  };

  supportsPassbook = function(userAgent) {
    if (/Safari/gi.test(userAgent) && !/Chrom/gi.test(userAgent)) {
      if (/iPhone; CPU iPhone OS 6/gi.test(userAgent)) {
        return true;
      }
      if (/iPod; CPU iPhone OS 6/gi.test(userAgent)) {
        return true;
      }
      if (/Mac OS X 10_8_[2-9]/gi.test(userAgent)) {
        return true;
      }
      if (/Mac OS X 10_9_[0-9]/gi.test(userAgent)) {
        return true;
      }
    }
    return false;
  };

  PassKit = function(account, secret) {
    var digest, getImageUsage, getPass, getPassByID, getTemplateFields, getTemplates, invalidatePass, issueMultiplePasses, issuePass, request, resetTemplate, testConnection, updatePass, updatePassByID, updateTemplate, uploadImage;

    if (!sanitize(account)) {
      throw new PassKitError("Account ID is required.");
    }
    if (!sanitize(secret)) {
      throw new PassKitError("Account Secret is required.");
    }
    digest = {
      counter: 0,
      HA1: null,
      nonce: null,
      opaque: null,
      qop: null,
      realm: null,
      time: new Date(0)
    };
    request = function(callback, options, body, stringify) {
      var auth, body_tmp, call, cloneObject, options_tmp;

      if (body == null) {
        body = null;
      }
      if (stringify == null) {
        stringify = false;
      }
      cloneObject = function(obj) {
        var key, temp;

        if ((obj == null) || typeof obj !== "object") {
          return obj;
        }
        temp = obj.constructor();
        for (key in obj) {
          temp[key] = cloneObject(obj[key]);
        }
        return temp;
      };
      options_tmp = cloneObject(options);
      body_tmp = '';
      call = function(retry) {
        var HA2, nonceClient, nonceCount, response;

        if (retry == null) {
          retry = false;
        }
        if (!options.host) {
          options.host = HOST;
        }
        if (!options.method) {
          options.method = "GET";
        }
        options.path = API + options.path;
        if (!options.port) {
          options.port = PORT;
        }
        HA2 = md5("" + options.method + ":" + options.path);
        nonceCount = ++digest.counter;
        nonceClient = generateHex();
        response = md5("" + digest.HA1 + ":" + digest.nonce + ":" + nonceCount + ":" + nonceClient + ":auth:" + HA2);
        if (!options.headers) {
          options.headers = {};
        }
        options.headers["Authorization"] = renderDigest({
          username: account,
          realm: digest.realm,
          nonce: digest.nonce,
          uri: options.path,
          response: response,
          opaque: digest.opaque,
          qop: digest.qop,
          nc: nonceCount,
          cnonce: nonceClient
        });
        if (body) {
          if (stringify) {
            body_tmp = querystring.stringify(body);
          } else {
            body_tmp = body;
          }
          options.headers["Content-Length"] = Buffer.byteLength(body_tmp, 'utf8');
          if (!options.headers["Content-Type"]) {
            options.headers["Content-Type"] = "application/x-www-form-urlencoded";
          }
        }
        return https.request(options, function(res) {
          res.setEncoding("utf-8");
          response = {
            statusCode: res.statusCode,
            headers: res.headers,
            body: ""
          };
          res.on("data", function(chunk) {
            return response.body += chunk;
          });
          return res.on("end", function() {
            var err, error;

            if (!retry && response.statusCode === 401) {
              options = options_tmp;
              auth(true);
              return;
            }
            try {
              response.json = JSON.parse(response.body);
            } catch (_error) {
              error = _error;
              response.json = {
                error: response.body
              };
            }
            if (response.statusCode === 200 && response.json.success) {
              err = null;
              delete response.json.success;
            } else {
              err = new PassKitError(response.json.error);
            }
            return callback(err, response);
          });
        }).end(body_tmp);
      };
      auth = function(retry) {
        var authOpts, newTime;

        if (retry == null) {
          retry = false;
        }
        newTime = new Date();
        authOpts = {
          host: HOST,
          method: "GET",
          path: API + "/authenticate/",
          port: PORT
        };
        return https.get(authOpts, function(res) {
          res.setEncoding("utf-8");
          return res.on("end", function() {
            var responseParams;

            responseParams = parseDigest(res.headers["www-authenticate"]);
            digest.realm = responseParams.realm;
            digest.nonce = responseParams.nonce;
            digest.opaque = responseParams.opaque;
            digest.qop = responseParams.qop;
            digest.HA1 = md5("" + account + ":" + digest.realm + ":" + secret);
            digest.time = newTime;
            return call(retry);
          });
        });
      };
      if (new Date - digest.time < 100000.) {
        return call();
      } else {
        return auth();
      }
    };
    testConnection = function(callback) {
      var opt;

      opt = {
        path: "/authenticate/"
      };
      return request(function(err, response) {
        return callback(err, null);
      }, opt);
    };
    getTemplateFields = function(name, callback, all) {
      var opt;

      if (all == null) {
        all = false;
      }
      if (!sanitize(name)) {
        callback(new PassKitError("Template name is required!"), null);
        return;
      }
      opt = {
        path: "/template/" + (encodeURIComponent(name)) + "/fieldnames/"
      };
      if (all) {
        opt.path += "full";
      }
      return request(function(err, response) {
        if (err) {
          if (response.statusCode === 404) {
            err.message = "Invalid template name!";
          }
          return callback(err, null);
        } else {
          return callback(err, response.json[name]);
        }
      }, opt);
    };
    getTemplates = function(callback) {
      var opt;

      opt = {
        path: "/template/list/"
      };
      return request(function(err, response) {
        if (err) {
          return callback(err, null);
        } else {
          return callback(err, response.json.templates);
        }
      }, opt);
    };
    resetTemplate = function(name, callback, push) {
      var opt;

      if (push == null) {
        push = false;
      }
      if (!sanitize(name)) {
        callback(new PassKitError("Template name is required!"), null);
        return;
      }
      opt = {
        path: "/template/" + (encodeURIComponent(name)) + "/reset/"
      };
      if (push) {
        opt.path += "push";
      }
      return request(function(err, response) {
        if (err) {
          if (response.statusCode === 404) {
            err.message = "Invalid template name!";
          }
          if (response.statusCode === 503) {
            err.message = "Template must be updated prior reset!";
          }
          return callback(err, null);
        } else {
          return callback(err, response.json);
        }
      }, opt);
    };
    updateTemplate = function(name, fields, callback, push, reset) {
      var opt;

      if (push == null) {
        push = false;
      }
      if (reset == null) {
        reset = false;
      }
      if (!sanitize(name)) {
        callback(new PassKitError("Template name is required!"), null);
        return;
      }
      opt = {
        method: "POST",
        path: "/template/update/" + (encodeURIComponent(name)) + "/"
      };
      if (reset) {
        opt.path += "reset/";
      }
      if (push) {
        opt.path += "push";
      }
      return request(function(err, response) {
        if (err) {
          if (response.statusCode === 404) {
            err.message = "Invalid template name!";
          }
          return callback(err, null);
        } else {
          return callback(err, response.json);
        }
      }, opt, fields, true);
    };
    getImageUsage = function(imageID, callback) {
      var opt;

      if (!sanitize(imageID)) {
        callback(new PassKitError("Image ID is required!"), null);
        return;
      }
      opt = {
        method: "GET",
        path: "/image/" + imageID + "/"
      };
      return request(function(err, response) {
        if (response.statusCode === 200) {
          if (response.json.Background) {
            callback(0, "background");
          }
          if (response.json.Footer) {
            callback(0, "footer");
          }
          if (response.json.Logo) {
            callback(0, "logo");
          }
          if (response.json.Icon) {
            callback(0, "icon");
          }
          if (response.json.Strip) {
            callback(0, "strip");
          }
          if (response.json.Thumbnail) {
            return callback(0, "thumbnail");
          }
        } else {
          if (response.statusCode === 404) {
            err.message = "Invalid image ID!";
          }
          return callback(err, null);
        }
      }, opt);
    };
    uploadImage = function(role, path, callback) {
      var exists;

      if (!(role === "background" || role === "footer" || role === "icon" || role === "logo" || role === "strip" || role === "thumbnail")) {
        callback(new PassKitError("Role must be valid string!"), null);
        return;
      }
      exists = fs.exists || require('path').exists;
      return exists(path, function(fileExists) {
        var fileType, uploadExtension;

        if (!fileExists) {
          callback(new PassKitError("Image does not exit: " + path + "!"), null);
          return;
        }
        fileType = mime.lookup(path);
        uploadExtension = fileType.replace("image/", '');
        if (!(fileType === "image/png" || fileType === "image/jpeg" || fileType === "image/gif")) {
          callback(new PassKitError("Invalid file type!"), null);
          return;
        }
        return fs.stat(path, function(err, stats) {
          if (err) {
            callback(err, null);
            return;
          }
          if (stats.size >= 1572864) {
            callback(new PassKitError("Image too large (larger than 1.5MB): " + stats.size + "!"), null);
            return;
          }
          return fs.readFile(path, function(err, data) {
            var CRLF, b, body, boundary, buffers, buffersLength, fileHeaders, inputHeaders, opt, separator, targetStart, _i, _j, _len, _len1;

            CRLF = "\r\n";
            boundary = "-----" + generateHex(12);
            separator = CRLF + "--" + boundary;
            fileHeaders = ["Content-Disposition: form-data; name=\"image\"; filename=\"image." + uploadExtension + "\"", "Content-Type: " + fileType];
            inputHeaders = ["Content-Disposition: form-data; name=\"type\""];
            buffers = [new Buffer(separator + CRLF + fileHeaders.join(CRLF) + CRLF + CRLF), data, new Buffer(separator + CRLF + inputHeaders.join(CRLF) + CRLF + CRLF), new Buffer(fileType), new Buffer(separator + "--")];
            if (process.version < 'v0.8') {
              buffersLength = 0;
              for (_i = 0, _len = buffers.length; _i < _len; _i++) {
                b = buffers[_i];
                buffersLength += b.length;
              }
              body = new Buffer(buffersLength);
              targetStart = 0;
              for (_j = 0, _len1 = buffers.length; _j < _len1; _j++) {
                b = buffers[_j];
                b.copy(body, targetStart);
                targetStart += b.length;
              }
            } else {
              body = Buffer.concat(buffers);
            }
            opt = {
              headers: {
                "Content-Type": "multipart/form-data; boundary=" + boundary
              },
              method: "POST",
              path: "/image/add/" + role + "/"
            };
            return request(function(err, response) {
              if (err) {
                return callback(err, null);
              } else {
                return callback(err, response.json);
              }
            }, opt, body);
          });
        });
      });
    };
    getPass = function(template, serial, callback) {
      var opt;

      if (!sanitize(template)) {
        callback(new PassKitError("Template name is required!"), null);
        return;
      }
      if (!sanitize(serial)) {
        callback(new PassKitError("Pass serial number is required!"), null);
        return;
      }
      opt = {
        method: "GET",
        path: "/pass/get/template/" + (encodeURIComponent(template)) + "/serial/" + (encodeURIComponent(serial)) + "/"
      };
      return request(function(err, response) {
        if (err) {
          return callback(err, null);
        } else {
          if (response.json.totalPasses) {
            return callback(err, response.json);
          } else {
            return callback(new PassKitError("Template name or serial number is invalid!"), null);
          }
        }
      }, opt);
    };
    getPassByID = function(passID, callback) {
      var opt;

      if (!sanitize(passID)) {
        callback(new PassKitError("Pass ID is required!"), null);
        return;
      }
      opt = {
        method: "GET",
        path: "/pass/get/passId/" + (encodeURIComponent(passID)) + "/"
      };
      return request(function(err, response) {
        if (err) {
          if (response.statusCode === 404) {
            err.message = "Invalid pass template name or serial number!";
          }
          return callback(err, null);
        } else {
          return callback(err, response.json);
        }
      }, opt);
    };
    invalidatePass = function(template, serial, fields, callback) {
      var opt;

      if (!sanitize(template)) {
        callback(new PassKitError("Template name is required!"), null);
        return;
      }
      if (!sanitize(serial)) {
        callback(new PassKitError("Pass serial number is required!"), null);
        return;
      }
      if (fields.removeBarcode === void 0) {
        fields.removeBarcode = true;
      }
      if (fields.removeLocations === void 0) {
        fields.removeLocations = true;
      }
      if (fields.removeRelevantDate === void 0) {
        fields.removeRelevantDate = true;
      }
      opt = {
        method: "POST",
        path: "/pass/invalidate/template/" + (encodeURIComponent(template)) + "/serial/" + (encodeURIComponent(serial)) + "/"
      };
      return request(function(err, response) {
        if (err) {
          if (response.statusCode === 404) {
            err.message = "Invalid pass template name or serial number!";
          }
          return callback(err, null);
        } else {
          return callback(err, response.json);
        }
      }, opt, fields, true);
    };
    issuePass = function(template, fields, callback) {
      var data, opt;

      if (!sanitize(template)) {
        callback(new PassKitError("Template name is required!"), null);
        return;
      }
      data = JSON.stringify(fields);
      opt = {
        headers: {
          "Content-Type": "application/json"
        },
        method: "POST",
        path: "/pass/issue/template/" + (encodeURIComponent(template)) + "/"
      };
      return request(function(err, response) {
        if (err) {
          if (response.statusCode === 404) {
            err.message = "Template name is invalid!";
          }
          return callback(err, null);
        } else {
          return callback(err, response.json);
        }
      }, opt, data);
    };
    issueMultiplePasses = function(template, passes, callback) {
      var data, opt;

      if (!sanitize(template)) {
        callback(new PassKitError("Template name is required!"), null);
        return;
      }
      if (!Object.keys(passes).length) {
        callback(new PassKitError("At least one pass must be provided!"), null);
        return;
      }
      if (Object.keys(passes).length > 100) {
        callback(new PassKitError("Too many passes provided!"), null);
        return;
      }
      data = JSON.stringify(passes);
      opt = {
        headers: {
          "Content-Type": "application/json"
        },
        method: "POST",
        path: "/pass/issue/batch/template/" + (encodeURIComponent(template)) + "/"
      };
      return request(function(err, response) {
        if (err) {
          if (response.statusCode === 404) {
            err.message = "Template name is invalid!";
          }
          return callback(err, null);
        } else {
          return callback(err, response.json);
        }
      }, opt, data);
    };
    updatePass = function(template, serial, fields, callback, push) {
      var opt;

      if (push == null) {
        push = true;
      }
      if (!sanitize(template)) {
        callback(new PassKitError("Template name is required!"), null);
        return;
      }
      if (!sanitize(serial)) {
        callback(new PassKitError("Pass serial number is required!"), null);
        return;
      }
      if (!Object.keys(fields).length) {
        callback(new PassKitError("Nothing to update!"), null);
        return;
      }
      opt = {
        method: "POST",
        path: "/pass/update/template/" + (encodeURIComponent(template)) + "/serial/" + (encodeURIComponent(serial)) + "/"
      };
      if (push) {
        opt.path += "push";
      }
      return request(function(err, response) {
        if (err) {
          if (response.statusCode === 404) {
            err.message = "Invalid pass template name or serial number!";
          }
          return callback(err, null);
        } else {
          return callback(err, response.json);
        }
      }, opt, fields, true);
    };
    updatePassByID = function(passID, fields, callback, push) {
      var opt;

      if (push == null) {
        push = true;
      }
      if (!sanitize(passID)) {
        callback(new PassKitError("Pass ID is required!"), null);
        return;
      }
      if (!Object.keys(fields).length) {
        callback(new PassKitError("Nothing to update!"), null);
        return;
      }
      opt = {
        method: "POST",
        path: "/pass/update/passid/" + (encodeURIComponent(passID)) + "/"
      };
      if (push) {
        opt.path += "push";
      }
      return request(function(err, response) {
        if (err) {
          if (response.statusCode === 404) {
            err.message = "Invalid pass template name or serial number!";
          }
          return callback(err, null);
        } else {
          return callback(err, response.json);
        }
      }, opt, fields, true);
    };
    return {
      request: request,
      testConnection: testConnection,
      getTemplates: getTemplates,
      getTemplateFields: getTemplateFields,
      resetTemplate: resetTemplate,
      updateTemplate: updateTemplate,
      getImageUsage: getImageUsage,
      uploadImage: uploadImage,
      getPass: getPass,
      getPassByID: getPassByID,
      invalidatePass: invalidatePass,
      issuePass: issuePass,
      issueMultiplePasses: issueMultiplePasses,
      updatePass: updatePass,
      updatePassByID: updatePassByID,
      helpers: {
        parsePassURL: parsePassURL,
        supportsPassbook: supportsPassbook
      },
      "private": {
        PassKitError: PassKitError,
        generateHex: generateHex,
        md5: md5,
        parseDigest: parseDigest,
        renderDigest: renderDigest,
        sanitize: sanitize
      }
    };
  };

  module.exports = PassKit;

}).call(this);
